#
# ZSH RC
#
# Zsh run-control file.
#
# `.zshrc' is sourced in interactive shells. It should contain commands
# to set up aliases, functions, options, key bindings, etc.
#
# Put stuff in conditional section of `~/.zshenv`.
# See comments in `~/.zshenv` for detailed summary.
#
# shellcheck disable=SC1090,SC1091

BREW_PREFIX="$(brew --prefix)"

# Fix Shell PATH Issue (overwritten by .zprofile)
DEFAULT_PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
# remove defaults from beginning of PATH
PATH="${PATH#"$DEFAULT_PATH:"}"
# put defaults back at end of PATH
PATH="$PATH:$DEFAULT_PATH"

########################################################################
########################################################################
##
##  1. SCRIPT / NON-INTERACTIVE / .zshenv
##
##  Only for NON-interactive shells (ie; scripts)
##  Put your script-only stuff here, otherwise
##  this section can be ignored.
##
########################################################################
if [[ "$SHLVL" -eq 1 && ! -o LOGIN ]]; then
: ######################################################################
# echo "$SHELL"



########################################################################
########################################################################
##
##  2. INTERACTIVE / PROMPT / .zshrc
##
##  This is executed only for interactive shells.
##  If you have a command-prompt, this conditional was met.
##  Put stuff here for prompt-based users only.
##
########################################################################
else
: ######################################################################
# echo "$SHELL::interactive"

#-----------------------------------------------------------------------
# Source/init Prezto.
#-----------------------------------------------------------------------

[[ -f "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]] && . "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"

# Prezto init will prepend PATH with `~/.gem/ruby/*/bin` directory in
# `/Users/seantrane/.zprezto/modules/ruby/init.zsh`, line 48.
# The following commands will strip this out, as `~/.gem/ruby/*/bin` is already in PATH.
_find_files_array=($(find -H "${ZDOTDIR:-$HOME}/.gem/ruby" -maxdepth 2 -perm -u+r -type d -name 'bin'))
for _file_path in "${_find_files_array[@]}"; do
  PATH="${PATH#"${_file_path}:"}"
done
unset _file_path _find_files_array

# Unalias `nocorrect` completions from: prezto/modules/utility/init.zsh
# unalias mkdir mv mysql rm

#-----------------------------------------------------------------------
# LOCAL/PRIVATE CONFIG
#-----------------------------------------------------------------------

# Stash your environment variables in ~/.localrc. This means they'll stay out
# of your main dotfiles repository (which may be public, like this one), but
# you'll have access to them in your scripts.
[[ -f "${ZDOTDIR:-$HOME}/.localrc" ]] && . "${ZDOTDIR:-$HOME}/.localrc"

#-----------------------------------------------------------------------
# ALIASES
#-----------------------------------------------------------------------
# Aliases should only be available to prompt-user (not scripts).

alias reload!='. ~/.zshrc'

# for file in ~/.dotfiles/{git,system}/aliases.sh; do
_find_files_array=($(find -H "$DOTFILES" -maxdepth 2 -perm -u+r -type f -name 'aliases.sh'))
for _file_path in "${_find_files_array[@]}"; do
  . "$_file_path"
done
unset _file_path _find_files_array

# load everything but the path and completion files:
# for file in ~/.dotfiles/{git,system}/{aliases,*}.zsh; do
_find_files_array=($(find -H "$DOTFILES" -maxdepth 2 -perm -u+r -type f -name '*.zsh'))
for _file_path in ${${_find_files_array:#*/path.zsh}:#*/completion.zsh}; do
  . "$_file_path"
done
unset _file_path _find_files_array

# `~/.aliases` can be used for private aliases.
[[ -f "${ZDOTDIR:-$HOME}/.aliases" ]] && . "${ZDOTDIR:-$HOME}/.aliases"

# moving-or-renaming-multiple-files
# http://www.mfasold.net/blog/2008/11/moving-or-renaming-multiple-files/
# “mmv *.dat *.dat_old” or “mmv foo.* bar.*”
# “mmv **/*2008.mp3 **/*2009.mp3”
autoload -U zmv
alias mmv='noglob zmv -W'

# http://apt-browse.org/browse/debian/wheezy/main/all/command-not-found/
[[ -f "/etc/zsh_command_not_found" ]] && . "/etc/zsh_command_not_found"

#-----------------------------------------------------------------------
# TAB COMPLETION
#-----------------------------------------------------------------------

# Disable autocorrect guesses. Happens when typing a wrong
# command that may look like an existing one.
unsetopt CORRECT

# This bunch of code displays red dots when autocompleting
# a command with the tab key, "Oh-my-zsh"-style.
expand-or-complete-with-dots() {
  echo -n "\e[31m......\e[0m"
  zle expand-or-complete
  zle redisplay
}
zle -N expand-or-complete-with-dots
bindkey "^I" expand-or-complete-with-dots

# fignore() An array containing the suffixes of files to be
# ignored during filename completion.  However, if completion only
# generates files with suffixes in this list, then these files are
# completed anyway.
typeset -Ua fignore=(
	.DS_Store
	__pycache__
	.zip
	.tgz
)

# REPORTTIME: commands whose combined user and system execution
# times (measured in seconds) are greater than this value have
# timing statistics printed for them.  Output is suppressed for
# commands executed within the line editor, including completion;
# commands explicitly marked with the time keyword still cause
# the summary to be printed in this case.
typeset REPORTTIME=5

# initialize autocomplete here, otherwise functions won't be loaded
# compinit flags are defined as follows
# -d FILE: dump a cache of compiled completion scripts to FILE
# -C: skip the security check entirely
# NOTE: will prevent changes from being made to the completions
# cached in the dump file
# -u: silently include all insecure files and directories
# -i: silently ignore all insecure files and directories
autoload -U compinit
compinit -u

# Initialize module to provide compatibility for bash-based completion functions
# autoload -U +X bashcompinit
# bashcompinit

# matches case insensitive for lowercase
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# pasting with tabs doesn't perform completion
zstyle ':completion:*' insert-tab pending

# Homebrew-Zsh help reset
if type "brew" &> /dev/null && [ -f "${BREW_PREFIX}/share/zsh/help" ]; then
  unalias run-help
  autoload run-help
  HELPDIR="${BREW_PREFIX}/share/zsh/help"; export HELPDIR
fi

# load every completion after autocomplete loads:
# for file in ~/.dotfiles/{git,system}/completion.zsh; do
_find_files_array=($(find -H "$DOTFILES" -maxdepth 2 -perm -u+r -type f -name 'completion.zsh'))
for _file_path in "${_find_files_array[@]}"; do
  . "$_file_path"
done
unset _file_path _find_files_array

# To activate Homebrew-Zsh-completions, add to .zshrc:
if [[ -f "${BREW_PREFIX}/share/zsh-completions" ]]; then
  fpath=("${BREW_PREFIX}/share/zsh-completions" $fpath)
fi

# z - jump around
# https://github.com/rupa/z
# Tracks your most used directories, based on 'frecency'.
# After a short learning phase, z will take you to the most 'frecent' directory
# that matches ALL of the regexes given on the command line, in order.
if [[ -f "$HOME/z/z.sh" ]]; then
  . "$HOME/z/z.sh"
elif type "brew" &> /dev/null && [[ -f "${BREW_PREFIX}/etc/profile.d/z.sh" ]]; then
  . "${BREW_PREFIX}/etc/profile.d/z.sh"
fi

#-----------------------------------------------------------------------
# Less - opposite of more
#-----------------------------------------------------------------------
# Less is a program similar to more (1), but which allows
# backward movement in the file as well as forward movement.
# Also, less does not have to read the entire input file
# before starting, so with large input files it starts up faster
# than text editors like vi.

# Set the default Less options.
# Mouse-wheel scrolling has been disabled by -X (disable screen clearing).
# Remove -X and -F (exit if the content fits on one screen) to enable it.
export LESS='-F -g -i -M -R -S -w -X -z-4'

# Set the Less input preprocessor.
# Try both `lesspipe` and `lesspipe.sh` as either might exist on a system.
# shellcheck disable=SC1009,SC1072,SC1073
# if (( $#commands[(i)lesspipe(|.sh)] )); then
#   export LESSOPEN="| /usr/bin/env $commands[(i)lesspipe(|.sh)] %s 2>&-"
# fi
lesspipe_file="${BREW_PREFIX}/bin/lesspipe.sh"
[[ -e "${BREW_PREFIX}/bin/lesspipe" ]] && lesspipe_file="${BREW_PREFIX}/bin/lesspipe"
LESSOPEN="|$lesspipe_file %s"; export LESSOPEN                     #(sh like shells)
type "setenv" &> /dev/null && setenv LESSOPEN "|$lesspipe_file %s" #(csh, tcsh)

#-----------------------------------------------------------------------
# PROMPT OPTIONS
#-----------------------------------------------------------------------

autoload -Uz promptinit
promptinit
prompt sorin


########################################################################
########################################################################
##
##  THE END: SCRIPT/INTERACTIVE CONDITIONAL CONFIGURATION
##
fi #####################################################################
########################################################################
